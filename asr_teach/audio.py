# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_audio.ipynb.

# %% auto 0
__all__ = ['SAMPLE_RATE', 'BUFFER_SECONDS', 'DTYPE', 'AudioBuffer']

# %% ../nbs/00_audio.ipynb 2
import numpy as np

# %% ../nbs/00_audio.ipynb 3
# audio constants
SAMPLE_RATE = 16_000
BUFFER_SECONDS = 2
DTYPE = np.float32

# %% ../nbs/00_audio.ipynb 4
class AudioBuffer:
    '''Buffers an array of audio streaming over a socket.
    '''
    def __init__(self, size=SAMPLE_RATE * BUFFER_SECONDS, 
                 dtype=DTYPE, like_array=None):
        
        # initialize the buffer
        self.size = size
        self.data = np.empty(size, dtype=dtype, like=like_array)
        
        # head for data buffer
        self.ptr = 0 
        # holds leftover samples
        self.rem = None 
        # flag for whether the buffer is full
        self.is_full = False 

        
    def accumulate(self, data: np.ndarray):
        '''Reads in and buffers the incoming `data`.
        '''
        # number of incoming samples
        num_samples = data.size
        
        # handle buffer overflow
        if self.ptr + num_samples >= self.size:

            # flag the buffer as full
            self.is_full = True

            # store the leftover samples
            valid = self.size - self.ptr
            self.data[self.ptr:] = data[:valid]
            self.rem = data[valid:]
        
        # buffer in the data
        else:
            self.data[self.ptr: self.ptr + num_samples] = data
            self.ptr += num_samples

            
    def get_data(self):
        '''Gets the data buffer.
        '''
        return self.data
    
    
    def reset(self):
        '''Resets buffer head for new, incoming data.
        '''
        self.ptr = 0
        self.is_full = False

        
    def flush(self):
        '''Puts remainder data on the buffer and moves the head forward.
        '''
        if self.rem:
            rem_sz = len(self.rem)
            self.data[:rem_sz] = self.rem
            self.ptr += rem_sz
            self.rem = None
