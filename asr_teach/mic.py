# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_mic.ipynb.

# %% auto 0
__all__ = ['MicStream', 'stream']

# %% ../nbs/01_mic.ipynb 2
import sys 
import queue

import zmq
import fire
import sounddevice as sd

# %% ../nbs/01_mic.ipynb 3
from .utils import SAMPLE_RATE, DEVICE, BLOCK_DURATION, DTYPE
from .utils import ZMQ_ARGS, PROTOCOL, ADDR, PORT

# %% ../nbs/01_mic.ipynb 4
class MicStream:
    def __init__(self,
                 sample_rate: float = None,
                 device: int = 0,
                 block_duration: int = 2500,
                 dtype: str = DTYPE,
                 addr: str = ADDR,
                 port: int = PORT,
                 protocol: str = PROTOCOL,
                 context=None,
                 q=None):
        
        # create the socket
        context = context or zmq.Context()
        socket = context.socket(zmq.PUSH)
        socket.bind(f'{protocol}://{addr}:{port}')
        self.socket = socket
        
        # queue to hold live mic data
        self.q = q or queue.Queue()

        # setting the sample rate and mic buffer size
        self.sample_rate = sample_rate or sd.query_devices(device, 'input')['default_samplerate']
        self.num_samples = int(sample_rate * block_duration)
        self.blocksize = self.num_samples // 1000

        
        def enqueue_audio(indata, frames, time, status):
            '''Places audio data on the queue.
            '''
            if any(indata):
                self.q.put(indata)
        
        # create the microphone streaming object
        self.stream = sd.InputStream(device=device,
                                     channels=1,
                                     callback=enqueue_audio,
                                     dtype=dtype,
                                     blocksize=self.blocksize,
                                     samplerate=self.sample_rate)
        
        
    def send_audio(self, indata, flags=0, copy=True, track=False):
        '''Sends a numpy array in a multi-part message.
        
        The first part of the message has the shape and type of the array.
        The second message has the raw array bytes. 
        '''
        # send the array info
        md = {'dtype': str(indata.dtype),
              'shape': indata.shape}
        self.socket.send_json(md, zmq.SNDMORE)
        # sends the array data
        self.socket.send(indata, flags, copy=copy, track=track)
        
        
    def run(self):
        '''Streams audio until the user stops or interrupts the process.
        '''
        # start the microphone stream
        self.stream.start()
        print('Streaming live mic audio...')
        while True:
            try:
                # send any audio on the queue
                if not self.q.empty():
                    self.send_audio(self.q.get())
                    
            except KeyboardInterrupt:
                print('User keyboard interrupt, stopping mic...')
                self.stream.close()
                break
                print('stream stopped')
                
            except Exception as e:
                print(f'Exception: {e}')
                raise
                
        print('Live mic stopped.')
            

# %% ../nbs/01_mic.ipynb 5
def stream(sample_rate: float = SAMPLE_RATE,
           device: int = DEVICE,
           block_duration: int = BLOCK_DURATION,
           **kwargs):
    '''Entrypoint for live microphone streaming over a port.
    '''
    # create and start the microphone stream
    mic = MicStream(sample_rate, device, block_duration, **kwargs)
    mic.run()
